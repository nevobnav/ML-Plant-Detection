#!/usr/bin/python3.6

import tensorflow as tf
from tensorflow import keras
import tensorflow.keras.layers as layers
import tensorflow.keras.models as models
import tensorflow.keras.preprocessing as prep

import shapely.geometry
import csv
import cv2
from PIL import Image, ImageDraw

import os
import numpy as np 
import matplotlib.pyplot as plt 
import skimage
from scipy.ndimage import filters
from scipy.optimize import minimize, differential_evolution

im_shape = (60, 60)
mask_shape = (60, 60)
SOFTMASKS = True

# =========================================== Functions ===========================================

def f(im, t, theta, soft=SOFTMASKS):
	"""Filter that maps im to a mask. t is the threshold value, theta is a tuple containing 2 parameters.
	If soft==True, the mask will be soft (floats), else it will be a binary image (ints: 0 or 1)."""
	m, sigma = theta
	# im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)
	im = skimage.color.rgb2yuv(im)
	im = im[:,:,2] + im[:,:,1]
	im = filters.minimum_filter(im, 2)
	im = -filters.gaussian_filter(im, sigma) 
	im = (im - im.min())/(im.max()-im.min())
	m = im >= t
	if soft:
		m = m.astype(float)
		m = filters.gaussian_filter(m, sigma=(1,1))
	return m

def get_mask_from_poly(xs, ys, in_shape, out_shape, soft=SOFTMASKS):
	"""Computes (soft) mask of shape out_shape from polygon represented by (xs, ys)."""
	poly = [(xs[k], ys[k]) for k in range(len(xs))]
	xs.append(xs[0])
	ys.append(ys[0])
	tmp = Image.new('L', in_shape, 0)
	ImageDraw.Draw(tmp).polygon(poly, outline=1, fill=1)
	mask = np.array(tmp)
	mask = cv2.resize(mask, out_shape)
	if soft:
		mask = mask.astype(float)
		mask = filters.gaussian_filter(mask, sigma=(1,1))
	return mask

def MaskLoss(true_mask, im, t, m, s):
	"""Compute the mse-loss of the mask generated by f compared to true_mask."""
	pred_mask = f(im, t, (m, s))
	mse = 1./(mask_shape[0]*mask_shape[1])*np.linalg.norm(true_mask.ravel()-pred_mask.ravel())
	return mse

def write_opt_params(im_tensor, mask_tensor, name='opt_params.txt'):
	"""Perform stochastic optimization to find the parameters of f that optimally approximate true mask in mask_tensor.
	The results are written to a txt file name."""
	opt_params = np.zeros((mask_tensor.shape[0], 3))
	for i in range(opt_params.shape[0]):
		print(i)
		true_mask = mask_tensor[i,:,:]
		im = im_tensor[i,:,:,:]
		objective = lambda params : MaskLoss(true_mask, im, params[0], params[1], params[2])
		t_opt, m_opt, s_opt = differential_evolution(objective, [(0,1), (0,10), (0,10)]).x #, disp=True).x
		opt_params[i,:] = [t_opt, m_opt, s_opt]
	f = open(name, 'w')
	for row in opt_params:
		f.write('{}, {}, {}\n'.format(row[0], row[1], row[2]))
	f.close()

def load_opt_params(name):
	"""Load numpy array with optimal parameter values from txt file name."""
	f = open(name, 'r')
	fl = f.readlines()
	n = len(fl)
	opt_params = np.zeros((n, 3))
	for i in range(n):
		l = fl[i].split(',')
		opt_params[i,:] = [float(l[0]), float(l[1]), float(l[2])]
	return opt_params

def show(im_arr, mask, pred_mask, text1='Ground Truth', text2='Predicted Mask'):
	fig, axs = plt.subplots(2,3)
	axs[0,0].imshow(im_arr, interpolation='bilinear')
	axs[0,1].imshow(mask, cmap='Greys_r')
	axs[0,2].imshow(im_arr, interpolation='bilinear')
	axs[0,2].imshow(mask, cmap='Greys_r', alpha=0.3)
	axs[1,0].imshow(im_arr, interpolation='bilinear')
	axs[1,1].imshow(pred_mask, cmap='Greys_r')
	axs[1,2].imshow(im_arr, interpolation='bilinear')
	axs[1,2].imshow(pred_mask, cmap='Greys_r', alpha=0.3)
	axs[0,0].text(-0.02*im_arr.shape[1], 0.5*im_arr.shape[0], text1, rotation = 90, ha='right', va='center')
	axs[1,0].text(-0.02*im_arr.shape[1], 0.5*im_arr.shape[0], text2, rotation = 90, ha='right', va='center')
	for ax in axs.ravel():
		ax.axis('off')
	se = np.linalg.norm(mask.ravel()-pred_mask.ravel())
	print('Sum Squared Error: {:.5f}'.format(se))
	plt.show()

# ============================================= Main =============================================
data_path = '/home/duncan/Documents/VanBoven/DL Datasets/Crop Mask/'
images = os.listdir(data_path)

csv_filename = 'via_export_csv.csv'
with open(csv_filename) as csvfile:
	reader = csv.DictReader(csvfile)
	bigdict = dict()
	for row in reader:
		imname = row['filename']
		exec('d = '+row['region_shape_attributes'])
		bigdict[imname] = (d['all_points_x'], d['all_points_y'])

NUM = 200				# number of images used for training
training_im_tensor   = np.zeros((NUM, *im_shape, 3), dtype=np.uint8)
testing_im_tensor    = np.zeros((len(images)-training_im_tensor.shape[0], *im_shape, 3), dtype=np.uint8)
training_mask_tensor = np.zeros((NUM, *mask_shape))
testing_mask_tensor  = np.zeros((len(images)-training_mask_tensor.shape[0], *mask_shape))

for (i, im_name) in enumerate(list(bigdict.keys())[:NUM]):
	im_arr = np.array(Image.open(data_path+im_name))
	training_im_tensor[i,:,:,:] = cv2.resize(im_arr, im_shape)
	xs, ys = bigdict[im_name]
	mask = get_mask_from_poly(xs, ys, (im_arr.shape[0], im_arr.shape[1]), mask_shape)
	training_mask_tensor[i,:] = mask

for (i, im_name) in enumerate(list(bigdict.keys())[NUM:]):
	im_arr = np.array(Image.open(data_path+im_name))
	testing_im_tensor[i,:,:,:] = cv2.resize(im_arr, im_shape)
	xs, ys = bigdict[im_name]
	mask = get_mask_from_poly(xs, ys, (im_arr.shape[0], im_arr.shape[1]), mask_shape)
	testing_mask_tensor[i,:] = mask

# write_opt_params(training_im_tensor, training_mask_tensor, name='training_opt_params.txt')
# write_opt_params(testing_im_tensor, testing_mask_tensor, name='testing_opt_params.txt')

opt_params_train = load_opt_params('training_opt_params.txt')
opt_params_test  = load_opt_params('testing_opt_params.txt')

# k = 56
# t, m, s = opt_params_train[k, :]
# print('{:.3f}, {:.3f}, {:.3f}'.format(t, m, s))
# show(training_im_tensor[k,:,:,:], training_mask_tensor[k,:,:], f(training_im_tensor[k,:,:], t, (m, s), soft=True), text2='Optimal Filter')

# t, m, s = opt_params_test[k, :]
# print('{:.3f}, {:.3f}, {:.3f}'.format(t, m, s))
# show(testing_im_tensor[k,:,:,:], testing_mask_tensor[k,:,:], f(testing_im_tensor[k,:,:], t, (m, s), soft=True), text2='Optimal Filter')

im = layers.Input(shape=(60,60,3))
x = layers.Conv2D(16, (3,3), activation='relu')(im)
x = layers.Conv2D(32, (3,3), activation='relu', padding='same')(x)
x = layers.MaxPooling2D((2,2))(x)
x = layers.Conv2D(64, (3,3), activation='relu', padding='same')(x)
x = layers.MaxPooling2D((2,2))(x)
x = layers.Conv2D(64, (3,3), activation='relu', padding='same')(x)
# x = layers.MaxPooling2D((2,2))(x)
x = layers.Flatten()(x)
x = layers.Dense(64, activation='relu')(x)
x = layers.Dense(16, activation='relu')(x)
t = layers.Dense(1, activation='sigmoid')(x)
m = layers.Dense(1, activation='relu')(x)
s = layers.Dense(1, activation='relu')(x)
model = keras.Model(inputs=im, outputs=[t, m, s])

def myLoss(y_true, y_pred):
	# return -np.log(1+1e-10-np.abs(y_true[0]-y_pred[0])) + (y_true[1]-y_pred[1])**2 + (y_true[2]-y_pred[2])**2
	return (y_true-y_pred)**2
	

model.compile(optimizer='rmsprop',
			  loss=myLoss,
			  metrics=['accuracy'])

model.fit(training_im_tensor, [opt_params_train[:,0], opt_params_train[:,1], opt_params_train[:,2]],
			epochs=1,
			steps_per_epoch=50,
			shuffle=True)

model.save('masker_thres.h5')

model = models.load_model('masker.h5')
predictions = model.predict(testing_im_tensor)
ts, ms, ss = predictions[0], predictions[1], predictions[2]
for k in [0, 2]:
	show(testing_im_tensor[k,:,:,:], testing_mask_tensor[k,:], f(testing_im_tensor[k,:,:,:], ts[k], (ms[k], ss[k])))
plt.show()

